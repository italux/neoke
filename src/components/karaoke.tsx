/**
 * This code was generated by v0 by Vercel.
 * @see https://v0.dev/t/40FWIx4rkdl
 * Documentation: https://v0.dev/docs#integrating-generated-code-into-your-nextjs-app
 */

/** Add fonts into your Next.js project:

import { Inter } from 'next/font/google'

inter({
  subsets: ['latin'],
  display: 'swap',
})

To read more about using these font, please visit the Next.js documentation:
- App Directory: https://nextjs.org/docs/app/building-your-application/optimizing/fonts
- Pages Directory: https://nextjs.org/docs/pages/building-your-application/optimizing/fonts
**/
"use client";

import { useState, useEffect } from "react";
import { Avatar, AvatarImage, AvatarFallback } from "@/components/ui/avatar";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";

const QUEUE_STORAGE_KEY = "karaokeQueue";
const CURRENT_MUSIC_STORAGE_KEY = "currentMusic";

const saveQueueToLocalStorage = (queue: any[]) => {
  localStorage.setItem(QUEUE_STORAGE_KEY, JSON.stringify(queue));
};

const loadQueueFromLocalStorage = (): any[] => {
  const savedQueue = localStorage.getItem(QUEUE_STORAGE_KEY);
  return savedQueue ? JSON.parse(savedQueue) : [];
};

const saveCurrentMusicToLocalStorage = (currentMusic: any) => {
  localStorage.setItem(CURRENT_MUSIC_STORAGE_KEY, JSON.stringify(currentMusic));
};

const loadCurrentMusicFromLocalStorage = (): any => {
  const savedCurrentMusic = localStorage.getItem(CURRENT_MUSIC_STORAGE_KEY);
  return savedCurrentMusic ? JSON.parse(savedCurrentMusic) : null;
};

export function Karaoke() {
  const [queue, setQueue] = useState<any[]>([]);
  const [currentMusic, setCurrentMusic] = useState<any>(null);
  const [currentVideo, setCurrentVideo] = useState<any>(null);
  const [isDataLoaded, setIsDataLoaded] = useState(false);
  const [editingIndex, setEditingIndex] = useState<number | null>(null);
  const [newName, setNewName] = useState("");
  const [newSong, setNewSong] = useState("");
  const [newVideoUrl, setNewVideoUrl] = useState("");
  const [newNameError, setNewNameError] = useState("");
  const [newVideoUrlError, setNewVideoUrlError] = useState("");

  useEffect(() => {
    // Load data from localStorage on component mount
    const storedQueue = loadQueueFromLocalStorage();
    setQueue(storedQueue);

    const storedCurrentMusic = loadCurrentMusicFromLocalStorage();
    setCurrentMusic(storedCurrentMusic);
    setCurrentVideo(storedCurrentMusic);

    setIsDataLoaded(true);
  }, []);

  useEffect(() => {
    if (isDataLoaded) {
      saveQueueToLocalStorage(queue);
    }
  }, [queue, isDataLoaded]);

  useEffect(() => {
    if (isDataLoaded) {
      saveCurrentMusicToLocalStorage(currentMusic);
    }
  }, [currentMusic, isDataLoaded]);

  useEffect(() => {
    if (isDataLoaded) {
      setCurrentMusic(currentVideo);
    }
  }, [currentVideo, isDataLoaded]);

  const handleDeleteFromQueue = (index: number) => {
    const updatedQueue = [...queue];
    updatedQueue.splice(index, 1);
    setQueue(updatedQueue);

    // If the current video is the one being removed, reset currentVideo
    if (currentVideo && (currentVideo as any).name === queue[index].name) {
      setCurrentVideo(null);
    }
  };

  const handleEditChange = (index: number, field: string, value: string) => {
    const updatedQueue = [...queue];
    updatedQueue[index] = {
      ...updatedQueue[index],
      [field]: value,
    };
    setQueue(updatedQueue);
  };

  const saveEdit = () => {
    // Optionally, add validation here
    setEditingIndex(null);
  };

  const cancelEdit = () => {
    // Reload the queue from localStorage to discard changes
    const storedQueue = loadQueueFromLocalStorage();
    setQueue(storedQueue);
    setEditingIndex(null);
  };

  const handleAddToQueue = () => {
    if (!newName) {
      setNewNameError("Name is required");
      return;
    } else {
      setNewNameError("");
    }
    const youtubeUrlRegex =
      /^(?:https?:\/\/)?(?:www\.)?(?:m\.)?(?:youtube\.com|youtu\.be)\/(?:watch\?v=|embed\/|v\/|shorts\/)?([a-zA-Z0-9_-]{11})(?:\S+)?$/;
    if (!newVideoUrl || !youtubeUrlRegex.test(newVideoUrl)) {
      setNewVideoUrlError("Invalid YouTube URL format");
      return;
    } else {
      setNewVideoUrlError("");
    }
    if (newName && newSong && newVideoUrl) {
      const newQueueItem = {
        name: newName,
        song: newSong,
        videoUrl: newVideoUrl,
      };
      const updatedQueue = [...queue, newQueueItem];
      setQueue(updatedQueue);
      setNewName("");
      setNewSong("");
      setNewVideoUrl("");
    }
  };

  const handlePlayVideo = (index: number) => {
    // Get the item to play
    const itemToPlay = queue[index];

    // Remove the item from the queue
    const updatedQueue = [...queue];
    updatedQueue.splice(index, 1);
    setQueue(updatedQueue);

    // Set the current video to the item being played
    setCurrentVideo(itemToPlay);
  };

  return (
    <div className="grid grid-cols-1 h-screen w-full bg-background text-foreground md:grid-cols-[500px_1fr]">
      <div className="border-b md:border-r p-6 space-y-4 overflow-auto">
        <h2 className="text-2xl font-bold">Karaoke Queue</h2>
        <div className="space-y-2">
          {queue.map((item, index) =>
            item.name ? (
              <div
                key={index}
                className="flex items-center justify-between bg-muted p-3 rounded-md"
                onDoubleClick={() => setEditingIndex(index)}
              >
                {editingIndex === index ? (
                  // Render editable inputs
                  <div className="flex items-center gap-3 w-full">
                    <Avatar className="w-8 h-8 border">
                      <AvatarImage src="" alt={`@${item.name}`} />
                      <AvatarFallback>
                        {item.name ? item.name.slice(0, 2) : "N/A"}
                      </AvatarFallback>
                    </Avatar>
                    <div className="grid gap-4 w-full">
                      <Input
                        value={item.name}
                        onChange={(e) =>
                          handleEditChange(index, "name", e.target.value)
                        }
                        placeholder="Enter Name"
                        required
                      />
                      <Input
                        value={item.song}
                        onChange={(e) =>
                          handleEditChange(index, "song", e.target.value)
                        }
                        placeholder="Enter Song"
                      />
                      <Input
                        value={item.videoUrl}
                        onChange={(e) =>
                          handleEditChange(index, "videoUrl", e.target.value)
                        }
                        placeholder="Enter Video URL"
                      />
                    </div>
                    <Button
                      variant="ghost"
                      size="icon"
                      onClick={() => saveEdit()}
                    >
                      <CheckIcon className="w-6 h-6 text-green-500" />
                    </Button>
                    <Button
                      variant="ghost"
                      size="icon"
                      onClick={() => cancelEdit()}
                    >
                      <XIcon className="w-6 h-6 text-red-500" />
                    </Button>
                  </div>
                ) : (
                  // Render item as usual
                  <div className="flex items-center justify-between w-full">
                    <div className="flex items-center gap-3">
                      <Avatar className="w-8 h-8 border">
                        <AvatarImage src="" alt={`@${item.name}`} />
                        <AvatarFallback>
                          {item.name ? item.name.slice(0, 2) : "N/A"}
                        </AvatarFallback>
                      </Avatar>
                      <div>
                        <div className="font-medium">
                          {item.name}
                        </div>
                        <div className="text-sm text-muted-foreground">
                          {item.song}
                        </div>
                      </div>
                    </div>
                    <div className="flex items-center">
                      <Button
                        variant="ghost"
                        size="icon"
                        onClick={() => handlePlayVideo(index)} // Pass the index instead of the item
                        aria-label="Play video"
                      >
                      <ArrowRightIcon className="w-6 h-6 text-muted-foreground" />
                      </Button>
                      <Button
                        variant="ghost"
                        size="icon"
                        onClick={() => handleDeleteFromQueue(index)}
                      >
                        <TrashIcon className="w-6 h-6 text-red-500" />
                      </Button>
                    </div>
                  </div>
                )}
              </div>
            ) : null
          )}
          <div className="flex items-center justify-between bg-muted p-3 rounded-md">
            <div className="flex items-center gap-3">
              <Avatar className="w-8 h-8 border">
                <AvatarFallback>N/A</AvatarFallback>
              </Avatar>
              <div className="grid gap-2 w-full">
                <Input
                  value={newName}
                  onChange={(e) => setNewName(e.target.value)}
                  placeholder="Enter Name"
                  required
                />
                {newNameError && (
                  <div className="text-red-500 text-sm">{newNameError}</div>
                )}
                <Input
                  value={newSong}
                  onChange={(e) => setNewSong(e.target.value)}
                  placeholder="Enter Song"
                />
                <Input
                  value={newVideoUrl}
                  onChange={(e) => setNewVideoUrl(e.target.value)}
                  placeholder="Enter Video URL"
                />
                {newVideoUrlError && (
                  <div className="text-red-500 text-sm">{newVideoUrlError}</div>
                )}
              </div>
            </div>
            <Button variant="ghost" size="icon" onClick={handleAddToQueue}>
              <PlusIcon className="w-6 h-6 text-green-500" />
            </Button>
          </div>
        </div>
      </div>
      <div className="flex flex-col items-center justify-center p-6 space-y-4">
        {currentVideo ? (
          <>
            <div className="aspect-video w-full rounded-lg overflow-hidden">
              <iframe
                src={`https://www.youtube.com/embed/${new URL(
                  currentVideo.videoUrl
                ).searchParams.get("v")}`}
                title="YouTube video player"
                frameBorder="0"
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
                allowFullScreen
                className="w-full h-full"
              />
            </div>
            <div className="text-center mt-4">
              <div className="text-2xl md:text-3xl font-bold">
                {currentVideo.name}
              </div>
              <div className="text-sm md:text-lg text-muted-foreground">
                Singing {currentVideo.song}
              </div>
            </div>
          </>
        ) : (
          <div className="text-center text-muted-foreground">
            No video currently playing
          </div>
        )}
      </div>
    </div>
  );
}

function ArrowRightIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      {...props}
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <path d="M5 12h14" />
      <path d="m12 5 7 7-7 7" />
    </svg>
  );
}

function PlusIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      {...props}
      xmlns="http://www.w3.org/2000/svg"
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      strokeWidth="2"
      strokeLinecap="round"
      strokeLinejoin="round"
    >
      <path d="M5 12h14" />
      <path d="M12 5v14" />
    </svg>
  );
}

function CheckIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      {...props}
      xmlns="http://www.w3.org/2000/svg"
      fill="none"
      viewBox="0 0 24 24"
      stroke="currentColor"
    >
      <path
        strokeLinecap="round"
        strokeLinejoin="round"
        strokeWidth={2}
        d="M5 13l4 4L19 7"
      />
    </svg>
  );
}

function XIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      {...props}
      xmlns="http://www.w3.org/2000/svg"
      fill="none"
      viewBox="0 0 24 24"
      stroke="currentColor"
    >
      <path
        strokeLinecap="round"
        strokeLinejoin="round"
        strokeWidth={2}
        d="M6 18L18 6M6 6l12 12"
      />
    </svg>
  );
}
function TrashIcon(props: React.SVGProps<SVGSVGElement>) {
  return (
    <svg
      {...props}
      xmlns="http://www.w3.org/2000/svg"
      fill="none"
      viewBox="0 0 24 24"
      stroke="currentColor"
    >
      <path
        strokeLinecap="round"
        strokeLinejoin="round"
        strokeWidth={2}
        d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6M9 7h6"
      />
    </svg>
  );
}
